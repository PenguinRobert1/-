<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simple Rhythm Game</title>
  <style>
    body {
      margin: 0;
      background: #0a0a0a;
      overflow: hidden;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
    }
    #menu {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 12px;
      box-shadow: 0 0 10px #0ff;
      z-index: 10;
    }
    #pauseMenu {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 20px #0ff;
      text-align: center;
      z-index: 20;
    }
    #pauseMenu button, #pauseMenu input {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      background-color: #111;
      color: #0ff;
      cursor: pointer;
      box-shadow: 0 0 10px #0ff inset;
    }
    #pauseMenu button:hover, #pauseMenu input:hover {
      background-color: #222;
    }
    select, button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      background-color: #111;
      color: #0ff;
      cursor: pointer;
      box-shadow: 0 0 10px #0ff inset;
    }
    select:hover, button:hover {
      background-color: #222;
    }
    canvas {
      display: block;
      margin: 80px auto;
      background: #121212;
      box-shadow: 0 0 40px #0ff;
      border-radius: 16px;
    }
    #stats {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 12px;
      box-shadow: 0 0 10px #0ff;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      z-index: 10;
    }
    #stats p {
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <div id="menu">
    <select id="songSelector">
      <option value="song.mp3">song1</option>
      <option value="song2.mp3">allmyselas</option>
      <option value="song3.mp3">3ds</option>
    </select>
    <button id="playButton">Play</button>
  </div>
  <div id="pauseMenu">
    <h2>Pause Menu</h2>
    <label for="noteSpeed">Note Speed:</label>
    <input type="number" id="noteSpeed" value="2" min="1" max="5" step="0.1" />
    <br />
    <button id="resumeButton">Resume</button>
  </div>
  <div id="stats">
    <p>Score: <span id="score">0</span></p>
    <p>Notes Hit: <span id="notesHit">0</span></p>
    <p>Missed Notes: <span id="missedNotes">0</span></p>
    <p>Accuracy: <span id="accuracy">0%</span></p>
  </div>
  <audio id="song" crossorigin="anonymous"></audio>
  <canvas id="gameCanvas" width="400" height="600"></canvas>

  <script>
    // DOM Elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const audio = document.getElementById('song');
    const playButton = document.getElementById('playButton');
    const songSelector = document.getElementById('songSelector');
    const pauseMenu = document.getElementById('pauseMenu');
    const resumeButton = document.getElementById('resumeButton');
    const noteSpeedInput = document.getElementById('noteSpeed');

    // Game Variables
    const songCharts = {
      "song.mp3": "./charts/song1.txt",
      "song2.mp3": "./charts/song2.txt",
      "song3.mp3": "./charts/song3.txt"
    };
    const hitZoneY = 500;
    let noteSpeed = 2;
    const dfjkKeys = ['d', 'f', 'j', 'k'];
    const lanesMap = { 'd': 50, 'f': 150, 'j': 250, 'k': 350 };
    
    // Key states to prevent key repeat issues
    const keyStates = {};
    
    // Animation frame ID for proper animation control
    let animationFrameId = null;

    let notes = [];
    let sliders = [];
    let hitEffects = [];
    let gameStarted = false;
    let paused = false;
    let score = 0;
    let notesHit = 0;
    let missedNotes = 0;
    let feedback = "";
    let feedbackTimer = 0;

    // Event Listeners - Fix the keydown handler
    document.removeEventListener('keydown', handleKeyDown); // Remove any existing listeners
    document.addEventListener('keydown', handleKeyDown);
    
    // Add keyup listener to track released keys
    document.addEventListener('keyup', (e) => {
      const key = e.key.toLowerCase();
      keyStates[key] = false;
    });
    
    // Remove the duplicate keydown listener and replace with a better debug logger
    document.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      console.log(`Key pressed: ${key}, Game Started: ${gameStarted}, Paused: ${paused}, KeyState: ${keyStates[key]}`);
    }, { once: false });
    
    playButton.addEventListener('click', handlePlayButton);
    resumeButton.addEventListener('click', resumeGame);
    noteSpeedInput.addEventListener('change', (e) => {
      noteSpeed = parseFloat(e.target.value);
    });

    // Game Functions
    function handleKeyDown(e) {
      const key = e.key.toLowerCase();
      
      // Prevent default only for game keys to avoid breaking other browser functionality
      if (key === 'escape' || dfjkKeys.includes(key)) {
        e.preventDefault();
      }
      
      // If key is already pressed down, ignore (prevents key repeat)
      if (keyStates[key]) return;
      keyStates[key] = true;
      
      if (key === 'escape') {
        togglePause();
      } else if (dfjkKeys.includes(key)) {
        if (paused) {
          resumeGame();
        } else if (gameStarted) {
          checkHit(key);
          checkSliderHit(key);
        }
      }
    }

    function handlePlayButton() {
      if (!gameStarted) {
        const selectedSong = songSelector.value;
        const chartFile = songCharts[selectedSong];
        loadChart(chartFile);
        audio.removeEventListener('loadedmetadata', startGame);
        audio.addEventListener('loadedmetadata', startGame, { once: true });
      }
    }

    function togglePause() {
      if (!gameStarted) return;
      
      if (!paused) {
        paused = true;
        audio.pause();
        showPauseMenu();
        
        // Cancel the animation frame when paused
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
      } else {
        resumeGame();
      }
    }

    function resumeGame() {
      paused = false;
      audio.play().catch(error => {
        console.error("Error resuming audio:", error);
      });
      hidePauseMenu();
      
      // Only request a new frame if one isn't already running
      if (!animationFrameId) {
        animationFrameId = requestAnimationFrame(gameLoop);
      }
    }

    function startGame() {
      if (notes.length === 0) {
        alert('No chart loaded. Please load a chart file.');
        return;
      }

      // Reset stats
      score = 0;
      notesHit = 0;
      missedNotes = 0;
      updateStats();

      gameStarted = true;
      audio.play().then(() => {
        requestAnimationFrame(gameLoop);
      }).catch(err => {
        alert("Autoplay is blocked. Click Play to start the audio.");
        console.error(err);
      });
    }

    function resetGame() {
      score = 0;
      notesHit = 0;
      missedNotes = 0;
      notes = [];
      sliders = [];
      hitEffects = [];
      feedback = "";
      feedbackTimer = 0;
      paused = false;
      gameStarted = false;
      
      // Reset key states
      dfjkKeys.forEach(key => keyStates[key] = false);
      
      // Cancel any existing animation
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      audio.currentTime = 0;
      audio.pause();
    }

    function gameLoop() {
      const now = audio.currentTime;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawHitZone();
      drawHitEffects();

      for (let note of notes) {
        if (note.hit) continue;
        const timeToNote = note.time - now;
        const y = hitZoneY - timeToNote * 100 * noteSpeed;

        if (y > canvas.height) {
          // Mark note as missed
          note.hit = true;
          missedNotes++;
          updateStats();
          continue;
        }

        if (y > canvas.height || y < -40) continue;
        drawNote(lanesMap[note.key], y);
      }

      if (gameStarted) requestAnimationFrame(gameLoop);
    }

    // Drawing Functions
    function drawNote(x, y) {
      ctx.fillStyle = '#0ff';
      ctx.beginPath();
      ctx.roundRect(x - 20, y - 20, 40, 40, 10);
      ctx.fill();
      
      // Add outline for better visibility
      ctx.strokeStyle = '#008888';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawSlider(x, y, length) {
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, y - length);
      ctx.stroke();
      
      // Add slider ends for better visibility
      ctx.fillStyle = '#0ff';
      ctx.beginPath();
      ctx.arc(x, y, 6, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(x, y - length, 6, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawHitZone() {
      // Draw hit line
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, hitZoneY);
      ctx.lineTo(canvas.width, hitZoneY);
      ctx.stroke();
      
      // Draw lane separators
      ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
      ctx.lineWidth = 1;
      for (let i = 1; i < dfjkKeys.length; i++) {
        const x = (lanesMap[dfjkKeys[i-1]] + lanesMap[dfjkKeys[i]]) / 2;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      // Draw hit buttons with key press visualization
      for (let key in lanesMap) {
        const x = lanesMap[key];
        
        // Button background
        ctx.fillStyle = keyStates[key] ? '#00aaaa' : '#555';
        ctx.beginPath();
        ctx.roundRect(x - 20, hitZoneY - 20, 40, 40, 10);
        ctx.fill();
        
        // Button outline
        ctx.strokeStyle = keyStates[key] ? '#0ff' : '#777';
        ctx.lineWidth = keyStates[key] ? 3 : 1;
        ctx.stroke();
        
        // Button label
        ctx.font = '20px Arial';
        ctx.fillStyle = keyStates[key] ? '#fff' : '#888';
        ctx.textAlign = 'center';
        ctx.fillText(key.toUpperCase(), x, hitZoneY + 8);
      }
    }

    function drawHitEffects() {
      for (let i = hitEffects.length - 1; i >= 0; i--) {
        const eff = hitEffects[i];
        ctx.beginPath();
        ctx.arc(eff.x, eff.y, eff.radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(0, 255, 255, ${eff.alpha})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        eff.radius += 2;
        eff.alpha -= 0.05;
        if (eff.alpha <= 0) hitEffects.splice(i, 1);
      }
    }

    function updateStats() {
      const totalNotes = notesHit + missedNotes;
      const accuracy = totalNotes > 0 ? ((notesHit / totalNotes) * 100).toFixed(2) : 0;

      document.getElementById('score').textContent = score;
      document.getElementById('notesHit').textContent = notesHit;
      document.getElementById('missedNotes').textContent = missedNotes;
      document.getElementById('accuracy').textContent = `${accuracy}%`;
    }

    // Utility Functions
    function loadChart(chartFile) {
      fetch(chartFile)
        .then(response => response.text())
        .then(textData => {
          parseChart(textData);
          audio.src = songSelector.value;
          audio.load();
        })
        .catch(error => {
          console.error("Error loading chart:", error);
          alert('Failed to load chart. Please check the file.');
          
          // Create some default notes for testing if chart fails to load
          createDummyChart();
          audio.src = songSelector.value;
          audio.load();
        });
    }
    
    function createDummyChart() {
      notes = [];
      sliders = [];
      
      // Create some basic notes
      for (let i = 0; i < 20; i++) {
        const key = dfjkKeys[i % 4];
        notes.push({
          time: 1 + i * 0.5,
          key: key,
          hit: false
        });
      }
      
      // Add a few sliders
      sliders.push({ startTime: 6, endTime: 7, key: 'd', hit: false });
      sliders.push({ startTime: 8, endTime: 9, key: 'f', hit: false });
      sliders.push({ startTime: 10, endTime: 11, key: 'j', hit: false });
      sliders.push({ startTime: 12, endTime: 13, key: 'k', hit: false });
    }

    function parseChart(data) {
      try {
        notes = [];
        sliders = [];
        
        if (!data || typeof data !== 'string') {
          console.error("Invalid chart data");
          createDummyChart();
          return;
        }
        
        const lines = data.split('\n');
        
        for (const line of lines) {
          if (!line || line.trim() === '') continue;
          
          // Parse notes
          const noteMatch = line.match(/Time: ([\d.]+), Note: (\w+)/);
          if (noteMatch && lanesMap[noteMatch[2]]) {
            notes.push({ 
              time: parseFloat(noteMatch[1]), 
              key: noteMatch[2], 
              hit: false 
            });
            continue;
          }
          
          // Parse sliders
          const sliderMatch = line.match(/Slider: StartTime: ([\d.]+), EndTime: ([\d.]+), Key: (\w+)/);
          if (sliderMatch && lanesMap[sliderMatch[3]]) {
            sliders.push({ 
              startTime: parseFloat(sliderMatch[1]), 
              endTime: parseFloat(sliderMatch[2]), 
              key: sliderMatch[3], 
              hit: false 
            });
          }
        }
        
        // If no valid notes were parsed, create dummy ones
        if (notes.length === 0 && sliders.length === 0) {
          console.warn("No valid notes or sliders found in chart");
          createDummyChart();
        }
      } catch (error) {
        console.error("Error parsing chart:", error);
        createDummyChart();
      }
    }

    function calculateRating(score, maxScore) {
      const percentage = (score / maxScore) * 100;
      if (percentage >= 95) return "S+";
      if (percentage >= 90) return "S";
      if (percentage >= 80) return "A";
      if (percentage >= 70) return "B";
      if (percentage >= 50) return "C";
      return "D";
    }

    function checkHit(key) {
      const now = audio.currentTime;
      for (let i = 0; i < notes.length; i++) {
        const note = notes[i];
        if (!note.hit && note.key === key && Math.abs(note.time - now) < 0.3) {
          note.hit = true;
          hitEffects.push({ x: lanesMap[key], y: hitZoneY, radius: 10, alpha: 1 });

          // Update stats
          score += 300; // Add points for a hit
          notesHit++;
          updateStats();

          return;
        }
      }

      // If no note was hit, count it as a miss
      missedNotes++;
      updateStats();
    }

    function checkSliderHit(key) {
      const now = audio.currentTime;
      for (let i = 0; i < sliders.length; i++) {
        const slider = sliders[i];
        // Slightly more lenient slider hit window
        if (!slider.hit && slider.key === key && 
            now >= slider.startTime - 0.25 && 
            now <= slider.endTime + 0.25) {
          slider.hit = true;
          score += 500; // Slider hit points
          feedback = "Slider Hit!";
          feedbackTimer = 30;
          hitEffects.push({ x: lanesMap[key], y: hitZoneY, radius: 15, alpha: 1 });
          return true;
        }
      }
      return false;
    }

    function showPauseMenu() {
      pauseMenu.style.display = 'block';
    }

    function hidePauseMenu() {
      pauseMenu.style.display = 'none';
    }

    function showGameOverScreen() {
      const maxPossibleScore = notes.length * 300 + sliders.length * 500;
      const maxScore = maxPossibleScore > 0 ? maxPossibleScore : 1; // Prevent division by zero
      const rating = calculateRating(score, maxScore);
      const percentage = (score / maxScore) * 100;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#121212';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.font = '40px Arial';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';

      if (percentage < 50) {
        ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 60);
        ctx.font = '20px Arial';
        ctx.fillText(`You scored less than 50%!`, canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText(`Rating: ${rating}`, canvas.width / 2, canvas.height / 2 + 60);
      } else {
        ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 60);
        ctx.font = '20px Arial';
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillText(`Rating: ${rating}`, canvas.width / 2, canvas.height / 2 + 20);
      }

      const tryAgainButton = document.createElement('button');
      tryAgainButton.textContent = 'Try Again';
      tryAgainButton.style.position = 'absolute';
      tryAgainButton.style.top = `${canvas.offsetTop + canvas.height / 2 + 100}px`;
      tryAgainButton.style.left = `${canvas.offsetLeft + canvas.width / 2}px`;
      tryAgainButton.style.transform = 'translateX(-50%)';
      tryAgainButton.style.padding = '10px 20px';
      tryAgainButton.style.fontSize = '16px';
      tryAgainButton.style.border = 'none';
      tryAgainButton.style.borderRadius = '8px';
      tryAgainButton.style.backgroundColor = '#111';
      tryAgainButton.style.color = '#0ff';
      tryAgainButton.style.cursor = 'pointer';
      tryAgainButton.style.boxShadow = '0 0 10px #0ff inset';

      document.body.appendChild(tryAgainButton);
      tryAgainButton.addEventListener('click', () => {
        document.body.removeChild(tryAgainButton);
        resetGame();
      });
    }
    
    // Initialize key states
    dfjkKeys.forEach(key => keyStates[key] = false);
    keyStates['escape'] = false;
  </script>
</body>
</html>