<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simple Rhythm Game</title>
  <style>
    body {
      margin: 0;
      background: #0a0a0a;
      overflow: hidden;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
    }
    #menu {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 12px;
      box-shadow: 0 0 10px #0ff;
      z-index: 10;
    }
    #pauseMenu {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 20px #0ff;
      text-align: center;
      z-index: 20;
    }
    #pauseMenu button, #pauseMenu input {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      background-color: #111;
      color: #0ff;
      cursor: pointer;
      box-shadow: 0 0 10px #0ff inset;
    }
    #pauseMenu button:hover, #pauseMenu input:hover {
      background-color: #222;
    }
    select, button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      background-color: #111;
      color: #0ff;
      cursor: pointer;
      box-shadow: 0 0 10px #0ff inset;
    }
    select:hover, button:hover {
      background-color: #222;
    }
    canvas {
      display: block;
      margin: 80px auto;
      background: #121212;
      box-shadow: 0 0 40px #0ff;
      border-radius: 16px;
    }
  </style>
</head>
<body>
  <div id="menu">
    <select id="songSelector">
      <option value="song.mp3">song1</option>
      <option value="song2.mp3">allmyselas</option>
      <option value="song3.mp3">3ds</option>
    </select>
    <button id="playButton">Play</button>
  </div>
  <div id="pauseMenu">
    <h2>Pause Menu</h2>
    <label for="noteSpeed">Note Speed:</label>
    <input type="number" id="noteSpeed" value="2" min="1" max="5" step="0.1" />
    <br />
    <button id="resumeButton">Resume</button>
  </div>
  <audio id="song" crossorigin="anonymous"></audio>
  <canvas id="gameCanvas" width="400" height="600"></canvas>

  <script>
    // DOM Elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const audio = document.getElementById('song');
    const playButton = document.getElementById('playButton');
    const songSelector = document.getElementById('songSelector');
    const pauseMenu = document.getElementById('pauseMenu');
    const resumeButton = document.getElementById('resumeButton');
    const noteSpeedInput = document.getElementById('noteSpeed');

    // Game Variables
    const songCharts = {
      "song.mp3": "./charts/song1.txt",
      "song2.mp3": "./charts/song2.txt",
      "song3.mp3": "./charts/song3.txt"
    };
    const hitZoneY = 500;
    let noteSpeed = 2;
    const dfjkKeys = ['d', 'f', 'j', 'k'];
    const lanesMap = { 'd': 50, 'f': 150, 'j': 250, 'k': 350 };

    let notes = [];
    let sliders = [];
    let hitEffects = [];
    let gameStarted = false;
    let paused = false;
    let score = 0;
    let feedback = "";
    let feedbackTimer = 0;

    // Event Listeners
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keydown', (e) => {
      console.log(`Key pressed: ${e.key}, Game Started: ${gameStarted}, Paused: ${paused}`);
    });
    playButton.addEventListener('click', handlePlayButton);
    resumeButton.addEventListener('click', resumeGame);
    noteSpeedInput.addEventListener('change', (e) => {
      noteSpeed = parseFloat(e.target.value);
    });

    // Game Functions
    function handleKeyDown(e) {
      e.preventDefault();
      if (e.key === 'Escape') {
        togglePause();
      } else if (dfjkKeys.includes(e.key)) {
        if (paused) {
          resumeGame();
        } else if (gameStarted) {
          checkHit(e.key);
          checkSliderHit(e.key);
        }
      }
    }

    function handlePlayButton() {
      if (!gameStarted) {
        const selectedSong = songSelector.value;
        const chartFile = songCharts[selectedSong];
        loadChart(chartFile);
        audio.removeEventListener('loadedmetadata', startGame);
        audio.addEventListener('loadedmetadata', startGame, { once: true });
      }
    }

    function togglePause() {
      if (!paused) {
        paused = true;
        audio.pause();
        showPauseMenu();
      } else {
        resumeGame();
      }
    }

    function resumeGame() {
      paused = false;
      audio.play();
      hidePauseMenu();
      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      score = 0;
      gameStarted = true;
      paused = false;
      audio.play().then(() => {
        requestAnimationFrame(gameLoop);
      }).catch(() => {
        alert("Autoplay is blocked. Click Play to start the audio.");
      });
      audio.addEventListener('ended', () => {
        gameStarted = false;
        showGameOverScreen();
      }, { once: true });
    }

    function resetGame() {
      score = 0;
      notes = [];
      sliders = [];
      feedback = "";
      feedbackTimer = 0;
      paused = false;
      gameStarted = false;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      audio.currentTime = 0;
      audio.pause();
    }

    function gameLoop() {
      if (paused || !gameStarted) return;
      const now = audio.currentTime;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawHitZone();
      drawHitEffects();
      drawScore();

      // Draw Notes
      for (let note of notes) {
        if (note.hit) continue;
        const timeToNote = note.time - now;
        const y = hitZoneY - timeToNote * 100 * noteSpeed;
        if (y > canvas.height || y < -40 || isNaN(y)) continue;
        drawNote(lanesMap[note.key], y);

        // Mark note as missed if it goes off-screen
        if (y > canvas.height && !note.hit) {
          note.hit = true;
          feedback = "Miss!";
          feedbackTimer = 30;
        }
      }

      // Draw Sliders
      for (let slider of sliders) {
        if (slider.hit) continue;
        const timeToSlider = slider.startTime - now;
        const y = hitZoneY - timeToSlider * 100 * noteSpeed;
        if (y > canvas.height || y < -40 || isNaN(y)) continue;
        const length = (slider.endTime - slider.startTime) * 100 * noteSpeed;
        drawSlider(lanesMap[slider.key], y, length);

        // Mark slider as missed if it goes off-screen
        if (y > canvas.height && !slider.hit) {
          slider.hit = true;
          feedback = "Miss!";
          feedbackTimer = 30;
        }
      }

      if (gameStarted) requestAnimationFrame(gameLoop);
    }

    // Drawing Functions
    function drawNote(x, y) {
      ctx.fillStyle = '#0ff';
      ctx.beginPath();
      ctx.roundRect(x - 20, y - 20, 40, 40, 10);
      ctx.fill();
    }

    function drawSlider(x, y, length) {
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, y - length);
      ctx.stroke();
    }

    function drawHitZone() {
      for (let key in lanesMap) {
        const x = lanesMap[key];
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.roundRect(x - 20, hitZoneY - 20, 40, 40, 10);
        ctx.fill();
        ctx.font = '20px Arial';
        ctx.fillStyle = '#888';
        ctx.textAlign = 'center';
        ctx.fillText(key.toUpperCase(), x - 12, hitZoneY + 35);
      }
    }

    function drawHitEffects() {
      for (let i = hitEffects.length - 1; i >= 0; i--) {
        const eff = hitEffects[i];
        ctx.beginPath();
        ctx.arc(eff.x, eff.y, eff.radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(0, 255, 255, ${eff.alpha})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        eff.radius += 2;
        eff.alpha -= 0.05;
        if (eff.alpha <= 0) hitEffects.splice(i, 1);
      }
    }

    function drawScore() {
      ctx.font = '20px Arial';
      ctx.fillStyle = '#fff';
      ctx.fillText(`Score: ${score}`, 10, 30);
      if (feedbackTimer > 0) {
        ctx.font = '30px Arial';
        ctx.fillStyle = '#0f0';
        ctx.textAlign = 'center';
        ctx.fillText(feedback, canvas.width / 2, 50);
        feedbackTimer--;
      }
    }

    // Utility Functions
    function loadChart(chartFile) {
      fetch(chartFile)
        .then(response => response.text())
        .then(textData => {
          parseChart(textData);
          audio.src = songSelector.value;
          audio.load();
        })
        .catch(() => {
          alert('Failed to load chart. Please check the file.');
        });
    }

    function parseChart(data) {
      notes = data.split('\n').map(line => {
        const match = line.match(/Time: ([\d.]+), Note: (\w+)/);
        if (match && lanesMap[match[2]]) {
          return { time: parseFloat(match[1]), key: match[2], hit: false };
        }
        return null;
      }).filter(note => note !== null);

      sliders = data.split('\n').map(line => {
        const match = line.match(/Slider: StartTime: ([\d.]+), EndTime: ([\d.]+), Key: (\w+)/);
        if (match && lanesMap[match[3]]) {
          return { startTime: parseFloat(match[1]), endTime: parseFloat(match[2]), key: match[3], hit: false };
        }
        return null;
      }).filter(slider => slider !== null);
    }

    function calculateRating(score, maxScore) {
      const percentage = (score / maxScore) * 100;
      if (percentage >= 95) return "S+";
      if (percentage >= 90) return "S";
      if (percentage >= 80) return "A";
      if (percentage >= 70) return "B";
      if (percentage >= 50) return "C";
      return "D";
    }

    function checkHit(key) {
      const now = audio.currentTime;
      for (let i = 0; i < notes.length; i++) {
        const note = notes[i];
        if (!note.hit && note.key === key) {
          const timeDifference = Math.abs(note.time - now);
          if (timeDifference < 0.15) { // Perfect hit
            note.hit = true;
            score += 300;
            feedback = "Perfect!";
            hitEffects.push({ x: lanesMap[key], y: hitZoneY, radius: 10, alpha: 1 });
          } else if (timeDifference < 0.25) { // Good hit
            note.hit = true;
            score += 200;
            feedback = "Good!";
            hitEffects.push({ x: lanesMap[key], y: hitZoneY, radius: 10, alpha: 1 });
          } else if (timeDifference < 0.35) { // Bad hit
            note.hit = true;
            score += 100;
            feedback = "Bad!";
            hitEffects.push({ x: lanesMap[key], y: hitZoneY, radius: 10, alpha: 1 });
          } else {
            feedback = "Miss!";
          }
          feedbackTimer = 30;
          return;
        }
      }
      feedback = "Miss!";
      feedbackTimer = 30;
    }

    function checkSliderHit(key) {
      const now = audio.currentTime;
      for (let i = 0; i < sliders.length; i++) {
        const slider = sliders[i];
        if (!slider.hit && slider.key === key && now >= slider.startTime && now <= slider.endTime) {
          slider.hit = true;
          score += 500; // Slider hit points
          feedback = "Slider Hit!";
          feedbackTimer = 30; // Display feedback for a short duration
          return;
        }
      }
    }

    function showPauseMenu() {
      pauseMenu.style.display = 'block';
    }

    function hidePauseMenu() {
      pauseMenu.style.display = 'none';
    }

    function showGameOverScreen() {
      const maxScore = notes.length * 300 + sliders.length * 500;
      const rating = calculateRating(score, maxScore);
      const percentage = (score / maxScore) * 100;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = '40px Arial';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';

      if (percentage < 50) {
        ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 60);
        ctx.font = '20px Arial';
        ctx.fillText(`You scored less than 50%!`, canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText(`Rating: ${rating}`, canvas.width / 2, canvas.height / 2 + 60);
      } else {
        ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 60);
        ctx.font = '20px Arial';
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillText(`Rating: ${rating}`, canvas.width / 2, canvas.height / 2 + 20);
      }

      const tryAgainButton = document.createElement('button');
      tryAgainButton.textContent = 'Try Again';
      tryAgainButton.style.position = 'absolute';
      tryAgainButton.style.top = `${canvas.offsetTop + canvas.height / 2 + 100}px`;
      tryAgainButton.style.left = `${canvas.offsetLeft + canvas.width / 2 - 50}px`;
      tryAgainButton.style.transform = 'translateX(-50%)';
      tryAgainButton.style.padding = '10px 20px';
      tryAgainButton.style.fontSize = '16px';
      tryAgainButton.style.border = 'none';
      tryAgainButton.style.borderRadius = '8px';
      tryAgainButton.style.backgroundColor = '#111';
      tryAgainButton.style.color = '#0ff';
      tryAgainButton.style.cursor = 'pointer';
      tryAgainButton.style.boxShadow = '0 0 10px #0ff inset';

      document.body.appendChild(tryAgainButton);
      tryAgainButton.addEventListener('click', () => {
        document.body.removeChild(tryAgainButton);
        resetGame();
      });
    }
  </script>
</body>
</html>

